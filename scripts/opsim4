#!/usr/bin/env python
from __future__ import division
from datetime import datetime
import logging
import logging.handlers
import os
import signal
import socket
import subprocess as sp
import time

from lsst.sims.ocs.configuration import SimulationConfig
from lsst.sims.ocs.database import SocsDatabase
from lsst.sims.ocs.kernel import Simulator
from lsst.sims.ocs.setup import create_parser, configure_logging, generate_logfile_path
from lsst.sims.ocs.setup import apply_file_config, read_file_config, set_log_levels, Tracking
from lsst.sims.ocs.utilities import expand_path

DDS_DOMAIN_ENV = "LSST_DDS_DOMAIN"
OSPL_URI_ENV = "OSPL_URI"

def get_port_address():
    """Check available ports for the central logger.
    """
    port_range = (26345, 26405)
    for port_number in range(port_range[0], port_range[1]):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            s.bind(("localhost", port_number))
        except socket.error as e:
            if e.errno == 98:
                s.close()
                continue
        s.close()
        return port_number

def stop_programs(lpid, spid, log):
    log.info("Stopping programs.")
    if spid is not None:
        try:
            os.waitpid(spid, 0)
        except OSError:
            # Scheduler PID is no longer present.
            pass
    if lpid is not None:
        # Pause so final log messages can make it, especially on exceptions.
        time.sleep(5.0)
        os.kill(lpid, signal.SIGKILL)

def main(args):
    log_pid = None
    sched_pid = None
    try:
        db = SocsDatabase(sqlite_save_path=args.sqlite_save_dir,
                          session_id_start=args.session_id_start,
                          sqlite_session_save_path=args.sqlite_session_save_dir)

        session_id = db.new_session(args.startup_comment)

        log_file = generate_logfile_path(args.log_path, session_id)
        console_detail, file_detail = set_log_levels(args.verbose)
        log_port = get_port_address()
        configure_logging(console_detail, file_detail, log_port)
        log_pid = sp.Popen(["central_logger", "--filename={}".format(log_file),
                            "--level={}".format(file_detail),
                            "--log-port={}".format(log_port)]).pid
        # Need time for the central logger to startup to catch all the log messages.
        time.sleep(5)

        tracking = Tracking(session_id, args.session_code, args.startup_comment)
        if args.track_session:
            if args.tracking_db is not None:
                tracking.opsim_tracking_url = args.tracking_db
            tracking.track_session()

        logger = logging.getLogger("opsim4")

        if DDS_DOMAIN_ENV in os.environ:
            logger.info("{} = {}".format(DDS_DOMAIN_ENV,
                                         os.environ[DDS_DOMAIN_ENV]))
        if OSPL_URI_ENV in os.environ:
            logger.info("{} = {}".format(OSPL_URI_ENV,
                                         os.environ[OSPL_URI_ENV]))

        start_time = datetime.now()

        configuration = SimulationConfig()
        configuration.load(args.config)
        configuration.load_proposals()
        logger.info("{} proposals active.".format(configuration.num_proposals))
        configuration.validate()

        # Get scheduler version number
        output = sp.Popen(["scheduler.py", "--version"], stdout=sp.PIPE, stderr=sp.PIPE).communicate()
        args.scheduler_version = output[1].strip()

        sch_cmd = ["scheduler.py", "-s", "--log-port={}".format(log_port),
                   "--console-format=Scheduler: %(message)s"]
        sch_cmd.extend(["-v" for i in range(args.verbose)])
        if args.scheduler_timeout is not None:
            sch_cmd.append("--timeout={}".format(args.scheduler_timeout))
        if args.profile:
            sch_cmd.append("--profile")

        logger.debug("Scheduler Command: {}".format(sch_cmd))
        sched_pid = sp.Popen(sch_cmd).pid

        breadcrumb = ".scheduler_{}".format(log_port)

        sim = Simulator(args, configuration, db)
        sim.initialize()
        wait_time = 0
        while not os.path.exists(breadcrumb):
            time.sleep(1)
            wait_time += 1
        os.remove(breadcrumb)
        logger.info("SOCS waited {} seconds for Scheduler to complete init.".format(wait_time))
        try:
            sim.run()
        except BaseException:
            if not sim.db.data_empty:
                sim.db.write()
            sim.finalize()
            raise

        sim.finalize()

        if args.save_config:
            config_dir = "config_{}".format(session_id)
            if args.config_save_dir == '':
                args.config_save_dir = config_dir
            else:
                args.config_save_dir = expand_path(os.path.join(args.config_save_dir, config_dir))
            if not os.path.exists(args.config_save_dir):
                os.makedirs(args.config_save_dir)
            configuration.save(args.config_save_dir)
            logger.info("Finished saving survey configuration")

        end_time = datetime.now()
        run_time = (end_time - start_time).total_seconds()
        logger.info("Total running time = {:.2f} seconds".format(run_time))
        if args.track_session:
            tracking.update_session("Simulation finished successfully in {:.2f} seconds".format(run_time))

    except BaseException as err:
        try:
            logger.exception("An exception was thrown in SOCS!")
            if args.track_session:
                tracking.update_session("Simulation was not completed correctly.")
        except UnboundLocalError:
            # Had issue before logger got setup.
            print(err.message)
            print(err.statement)

    finally:
        try:
            logger.info("Waiting for Scheduler to finish.")
            stop_programs(log_pid, sched_pid, logger)
        except UnboundLocalError:
            # Had issue before logger got setup, do nothing here since nothing got started.
            pass


if __name__ == "__main__":
    parser = create_parser()
    args = parser.parse_args()
    # Handling weird issue with the startup comment argument.
    if isinstance(args.startup_comment, list):
        args.startup_comment = " ".join(args.startup_comment)

    # Apply program configuration file defaults if present.
    prog_conf = read_file_config()
    if prog_conf is not None:
        apply_file_config(prog_conf, args)

    if args.profile:
        import cProfile
        cProfile.run("main(args)", "socs_prof_{}.dat".format(datetime.now().strftime("%Y-%m-%d_%H:%M:%S")))
    else:
        main(args)
